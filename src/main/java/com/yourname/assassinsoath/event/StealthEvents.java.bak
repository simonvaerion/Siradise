package com.yourname.assassinsoath.event;

import com.yourname.assassinsoath.AssassinsOath;
import com.yourname.assassinsoath.ai.StealthAwarenessTracker;
import com.yourname.assassinsoath.network.S2CStealthHud;
import com.yourname.assassinsoath.network.StealthChannel;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.util.Mth;
import net.minecraft.world.entity.Mob;
import net.minecraft.world.entity.monster.Enemy;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.level.LightLayer;
import net.minecraft.world.level.Level;
import net.minecraftforge.event.TickEvent;
import net.minecraftforge.event.entity.EntityJoinLevelEvent;
import net.minecraftforge.event.entity.living.LivingEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.network.PacketDistributor;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@Mod.EventBusSubscriber(modid = AssassinsOath.MODID)
public final class StealthEvents {
    private StealthEvents() {}

    private static final Map<UUID, HudSnapshot> LAST_CLIENT_STATE = new HashMap<>();

    @SubscribeEvent
    public static void onPlayerTick(TickEvent.PlayerTickEvent event) {
        if (event.phase != TickEvent.Phase.END) return;
        if (!(event.player instanceof ServerPlayer player)) return;

        if (player.tickCount % 10 != 0) return; // sync at most every half second

        float detection = 0f;
        Level level = player.level();
        List<Mob> mobs = level.getEntitiesOfClass(Mob.class, player.getBoundingBox().inflate(20.0),
                mob -> mob.isAlive() && mob instanceof Enemy && !mob.isAlliedTo(player));
        for (Mob mob : mobs) {
            float value = computeDetection(mob, player);
            if (value > detection) detection = value;
        }
        int stage = StealthAwarenessTracker.stageFor(detection);

        HudSnapshot snapshot = LAST_CLIENT_STATE.get(player.getUUID());
        if (snapshot == null || snapshot.stage != stage || Math.abs(snapshot.visibility - detection) > 0.02f) {
            StealthChannel.CHANNEL.send(PacketDistributor.PLAYER.with(() -> player),
                    new S2CStealthHud(detection, stage));
            LAST_CLIENT_STATE.put(player.getUUID(), new HudSnapshot(detection, stage));
        }
    }

    @SubscribeEvent
    public static void onMobTick(LivingEvent.LivingTickEvent event) {
        if (!(event.getEntity() instanceof Mob mob)) return;
        if (mob.level().isClientSide) return;

        StealthAwarenessTracker.tick(mob);

        if (mob.tickCount % 5 != 0) return;

        Player candidate = mob.getTarget() instanceof Player target && !target.isSpectator() ? target
                : mob.level().getNearestPlayer(mob, 16.0);
        if (candidate == null || candidate.isSpectator()) return;

        float detection = computeDetection(mob, candidate);
        int stage = StealthAwarenessTracker.stageFor(detection);
        if (detection <= 0.05f && StealthAwarenessTracker.get(mob).isEmpty()) return;

        StealthAwarenessTracker.update(mob, candidate, detection, stage);
        if (stage >= 3 && mob.getTarget() == null) {
            mob.setTarget(candidate);
        }
    }

    @SubscribeEvent
    public static void onEntityJoin(EntityJoinLevelEvent event) {
        if (!(event.getEntity() instanceof Mob mob)) return;
        if (event.getLevel().isClientSide()) return;

        mob.goalSelector.addGoal(3, new com.yourname.assassinsoath.ai.goal.SearchLookGoal(mob));
        mob.goalSelector.addGoal(4, new com.yourname.assassinsoath.ai.goal.InvestigateSoundGoal(mob));
    }

    private static float computeDetection(Mob mob, Player player) {
        double maxRange = 18.0;
        double distance = mob.distanceTo(player);
        if (distance > maxRange) return 0f;
        double distanceScore = 1.0 - (distance / maxRange);

        double losMultiplier = mob.hasLineOfSight(player) ? 1.0 : 0.35;
        double crouch = player.isCrouching() ? 0.6 : 1.0;
        double sprint = player.isSprinting() ? 1.2 : 1.0;
        double velocity = Mth.clamp(player.getDeltaMovement().length() * 4.0 + 0.3, 0.3, 1.3);

        Level level = mob.level();
        int sky = level.getBrightness(LightLayer.SKY, player.blockPosition());
        int block = level.getBrightness(LightLayer.BLOCK, player.blockPosition());
        double light = Mth.clamp((sky + block) / 30.0, 0.2, 1.0);

        double base = distanceScore * losMultiplier * crouch * sprint * velocity * light;
        return Mth.clamp((float) base, 0f, 1f);
    }

    private record HudSnapshot(float visibility, int stage) {}
}
